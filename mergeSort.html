<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Merge Sort Network</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
    }

    /* Left code panel */
    #code-panel {
      width: 35%;
      background: #1e1e2c;
      color: #ddd;
      padding: 20px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 1vw;
      border-right: 2px solid #333;
    }
    .node-highlight {
  stroke: #FFEF00;
  stroke-width: 40;
}
/* Top-left buttons container */
#top-buttons {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 9999;
  display: flex;
  gap: 14px;
}

/* Subtle text-only buttons */
.top-btn {
  background: none;
  border: none;
  color: #bbb;
  font-size: 18px;
  cursor: pointer;
  padding: 4px 6px;
  transition: color 0.15s;
}

.top-btn:hover {
  color: #fff;
}

/* Add top padding to code panel so buttons do not overlap */
#code-panel {
  padding-top: 60px !important;
}

/* Help modal */
#help-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(2px);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

#help-content {
  background: white;
  width: 450px;
  padding: 20px 30px;
  border-radius: 12px;
  font-size: 18px;
  color: #333;
  line-height: 1.5;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}

#close-help {
  margin-top: 20px;
  display: block;
  width: 100%;
  padding: 10px;
  border: none;
  background: #444;
  color: white;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
#close-help:hover {
  background: #222;
}



    .code-line {
      padding: 3px 6px;
      border-radius: 4px;
    }

    .highlight {
      background: #FFEF00;
      color: black;
    }

    /* Right graph panel */
    #graph {
      flex: 1;
    }

    line {
      stroke: #999;
      stroke-opacity: 0.6;
    }

    circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }

    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 22px;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>

<body>
    <!-- Top-left Buttons -->
<div id="top-buttons">
  <button class="top-btn" onclick="window.location.href='index.html'">HOME</button>
  <button class="top-btn" onclick="openHelp()">EXPLAIN</button>
</div>

<!-- Help Popup Modal -->
<div id="help-modal">
  <div id="help-content">
    <h2>Graph Explanation</h2>

    <p><strong>Node Colours:</strong><br>
    The darker the nodes occupy a greater percentage of the algorithm runtime.</p>

    <p><strong>Node Size:</strong><br>
    Larger nodes are run a greater number of times.</p>

    <p><strong>Edge Length:</strong><br>
    The closer a pair of nodes are, the more often they have been run together.</p>

    <p><strong>What Merge Sort Does:</strong><br>
    This is a sorting algorithm which orders a list of values by splitting repeatedly.</p>
    The process continues until comparing single values, at which point ordering is trivial.</p>

    <button id="close-help" onclick="closeHelp()">Close</button>
  </div>
</div>


  <!-- Left panel showing code -->
  <div id="code-panel">
    <pre>
    <span id="line-1" class="code-line">def ms(a):</span>
    <span id="line-2" class="code-line">    if len(a)<=1:</span>
    <span id="line-3" class="code-line">        return a</span>
    <span id="line-4" class="code-line">    m = len(a)//2</span>
    <span id="line-5" class="code-line">    l = ms(a[:m])</span>
    <span id="line-6" class="code-line">    r = ms(a[m:])</span>
    <span id="line-7" class="code-line">    i=j=0</span>
    <span id="line-8" class="code-line">    o=[]</span>
    <span id="line-9" class="code-line">    while i&lt;len(l) and j&lt;len(r):</span>
    <span id="line-10" class="code-line">        if l[i]&lt;r[j]:</span>
    <span id="line-11" class="code-line">            o.append(l[i]); i+=1</span>
    <span id="line-12" class="code-line">        else:</span>
    <span id="line-13" class="code-line">            o.append(r[j]); j+=1</span>
    <span id="line-14" class="code-line">    o+=l[i:]; o+=r[j:]</span>
    <span id="line-15" class="code-line">    return o</span>
    <span id="line-16" class="code-line"></span>
    <span id="line-17" class="code-line">ms([5,2,7,1,4])</span>

    </pre>
  </div>

  <!-- Graph area -->
  <div id="graph"></div>

  <div id="tooltip" class="tooltip"></div>

  <script>
      function openHelp() {
  document.getElementById("help-modal").style.display = "flex";
}

function closeHelp() {
  document.getElementById("help-modal").style.display = "none";
}

    // Example nodes (each maps to a line number)
      <!-- fetch("mergeSort_data.json") -->
    fetch("mergeSort_data.json?v=" + Date.now())
  .then(response => response.json())
  .then(data => {
      const nodes = data.nodes;
      const links = data.links;

      buildGraph(nodes, links);
  });

    const width = window.innerWidth * 0.65;
    const height = window.innerHeight;

    const svg = d3.select("#graph")
      .append("svg")
      .attr("width", width)
      .attr("height", height);
    
    const container = svg.append("g");
    const zoom = d3.zoom()
  .scaleExtent([0.1, 4])   // min/max zoom
  .on("zoom", (event) => {
    container.attr("transform", event.transform);
  });

svg.call(zoom);


    svg.append("defs").append("marker")
    .attr("id", "arrow")
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 50)       // adjust depending on node radius
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#999");


    const tooltip = d3.select("#tooltip");
function buildGraph(nodes, links) {

    // 1. Group nodes by size
const groups = d3.group(nodes, d => d.size);

// 2. Precompute cluster centers based on sorted unique sizes
const uniqueSizes = Array.from(groups.keys()).sort((a,b) => a - b);
const clusterCenters = new Map();

const clusterSpacing = 180;     // distance between groups
const centerX = width / 2;
const centerY = height / 2;

// Place clusters horizontally
uniqueSizes.forEach((size, i) => {
  const x = centerX + (i - uniqueSizes.length / 2) * clusterSpacing;

  const y = centerY + (i - uniqueSizes.length / 2) * clusterSpacing;
  <!-- const y = centerY; -->
  clusterCenters.set(size, { x, y });
});

// 3. Assign each node an initial position near its cluster center  
groups.forEach((nodesOfSize, size) => {
  const c = clusterCenters.get(size);
  nodesOfSize.forEach(n => {
    n.x = c.x + (Math.random() - 0.5) * 40;  // small jitter
    n.y = c.y + (Math.random() - 0.5) * 40;
  });
});

    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links)
            .id(d => d.id)
            .distance(d => d.length)
        )
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => d.size + 4)); // ← add this
    
    const adjacency = new Map();
    nodes.forEach(n => adjacency.set(n.id, new Set()));
    links.forEach(l => {
      adjacency.get(l.source.id).add(l.target.id);
      adjacency.get(l.target.id).add(l.source.id);
    });




    const link = container.selectAll("line")
        .data(links)
        .enter().append("line");
    
    const arrows = container.selectAll(".arrow")
      .data(links)
      .enter()
      .append("path")
      .attr("class", "arrow")
      .attr("fill", "#999");


    const node = container.selectAll("circle")
      .data(nodes)
      .enter().append("circle")
      .attr("r", d => d.size)
      .attr("fill", d => d.color)
    .on("mouseout", () => {
        tooltip.style("opacity", 0);
        d3.selectAll(".code-line").classed("highlight", false);

        // Restore full opacity
        node.style("opacity", 1);
        link.style("opacity", 1);
    })

    .on("mouseover", (event, d) => {
        tooltip
            .style("opacity", 1)
            .html(`<strong>Runtime (%):</strong> ${d.runtimePercent}<br><strong>Execution Count (%):</strong> ${d.execCount}<br><strong>Line:</strong> ${d.line}`);

        // Highlight code
        d3.selectAll(".code-line").classed("highlight", false);
        d3.select("#line-" + d.line).classed("highlight", true);

        // Dim unrelated nodes
        const neighbors = adjacency.get(d.id);
        node.style("opacity", n =>
            (n.id === d.id || neighbors.has(n.id)) ? 1 : 0.15
        );

        link.style("opacity", l =>
            (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1
        );
    })
.on("mousemove", (event, d) => {
    // Convert graph coordinates to SVG screen coordinates
    const pt = svg.node().createSVGPoint();
    pt.x = d.x;
    pt.y = d.y;

    const screen = pt.matrixTransform(container.node().getCTM());

    // Get bounding box of the graph DIV relative to the page
    const graphRect = document
        .getElementById("graph")
        .getBoundingClientRect();

    tooltip.style("left", (graphRect.left + screen.x + 15) + "px")
           .style("top",  (graphRect.top  + screen.y + 15) + "px");
})
      .call(d3.drag()
        .on("start", dragstart)
        .on("drag", dragdrag)
        .on("end", dragend)
      );

    function autoZoomToFit() {
  // Compute bounds of all nodes
  const minX = d3.min(nodes, d => d.x);
  const maxX = d3.max(nodes, d => d.x);
  const minY = d3.min(nodes, d => d.y);
  const maxY = d3.max(nodes, d => d.y);

  const nodeWidth = maxX - minX;
  const nodeHeight = maxY - minY;

  // Padding around nodes
  const padding = 800;

  // Compute required scale
  const scale = Math.min(
    (width - padding) / nodeWidth,
    (height - padding) / nodeHeight,
    1.2                       // do not zoom in more than normal
  );

  // Compute center offset
  const translateX = width / 2 - (minX + nodeWidth / 2) * scale;
  const translateY = height / 2 - (minY + nodeHeight / 2) * scale;

  // Smooth animation
  svg.transition()
    .duration(3000)
    .call(
      zoom.transform,
      d3.zoomIdentity.translate(translateX, translateY).scale(scale)
    );
}
setTimeout(() => autoZoomToFit(), 50);

    // Map line number → node DOM element
const lineToNode = new Map();
node.each(function(d) {
  lineToNode.set(d.line, d3.select(this));
});

    // Add hover → highlight node for each code line
d3.selectAll(".code-line")
  .on("mouseover", function(event) {
      const lineNum = +this.id.replace("line-", "");
      const n = lineToNode.get(lineNum);
      if (n) {
        n.classed("node-highlight", true);
      }
  })
  .on("mouseout", function(event) {
      const lineNum = +this.id.replace("line-", "");
      const n = lineToNode.get(lineNum);
      if (n) {
        n.classed("node-highlight", false);
      }
  });




    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
          arrows.attr("d", d => {

    const src = d.source;
    const tgt = d.target;

    // Vector from src → tgt
    const dx = tgt.x - src.x;
    const dy = tgt.y - src.y;
    const len = Math.sqrt(dx*dx + dy*dy);

    // Normalize
    const ux = dx / len;
    const uy = dy / len;

    // Pull arrowhead back so its tip sits exactly at the target circle edge
    // (target.radius = target.size)
    const arrowTipX = tgt.x - ux * tgt.size;
    const arrowTipY = tgt.y - uy * tgt.size;

    // Arrowhead size (constant visually)
    const aw = 5; // width
    const ah = 8; // length

    // Base of arrow
    const baseX = arrowTipX - ux * ah;
    const baseY = arrowTipY - uy * ah;

    // Perpendicular vector
    const px = -uy;
    const py = ux;

    // Triangle corners
    const leftX = baseX + px * aw/2;
    const leftY = baseY + py * aw/2;

    const rightX = baseX - px * aw/2;
    const rightY = baseY - py * aw/2;

    return `
      M ${arrowTipX} ${arrowTipY}
      L ${leftX} ${leftY}
      L ${rightX} ${rightY}
      Z
    `;
  });
    });

    function dragstart(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragdrag(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragend(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
}
  </script>

</body>
</html>

